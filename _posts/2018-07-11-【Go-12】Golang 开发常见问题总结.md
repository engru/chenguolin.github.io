---
layout:  post    # 使用的布局（不需要改）
catalog: true   # 是否归档
author: 陈国林 # 作者
tags:         #标签
    - Go
---

# 一. 问题总结

文章的目的是为了把使用Golang开发过程中遇到的相关问题记录汇总下来，方便后续再碰到的时候可以快速解决

1. HTTPS请求报 `x509: certificate signed by unknown authority`  
   问题原因: HTTPS证书校验失败  
   解决方案: 定义TLSClientConfig 忽略证书校验
   ```
   tr := &http.Transport {
       TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
   }
   
   client := &http.Client{Transport: tr}
   ```
   
2. Go主协程需要等待其它协程结束后再退出，否则会导致goroutine未结束进程就退出了  
   通常情况下我们会使用一个channel来实现，具体的实现原理是 `channel在没有数据的时候接收操作会一直阻塞`，当所有的goroutine都结束的时候可以close掉这个channel，这样接收操作就不会阻塞，主协程就可以继续往下执行
   ```
   func main() {
       ...
    
       // block until shutdown channel closed
       shutdown := make(chan struct{})
       registerSignal(shutdown)
       // 一直阻塞直到shutdown有数据 或者 被close
       <-shutdown
    
       ...
   }

   // registerSignal register kill signal
   func registerSignal(shutdown chan struct{}) {
       c := make(chan os.Signal)
       signal.Notify(c, os.Interrupt, syscall.SIGHUP, syscall.SIGINT, syscall.SIGTERM)

       go func() {
           defer func() {
           if err := recover(); err != nil {
               log.Error("[registerSignal] panic error: ", log.Object("error", err))
               debug.PrintStack()
           }
       }()

       for sig := range c {
 	       // close shutdown channel
           close(shutdown)
           log.Info("[registerSignal] receive system signal:" + sig.String() + ", going to shutdown ...")
           return
       }
   }()
   ```

3. 正常情况for循环遍历map是不稳定，key/value输出顺序会变化
   ```
   m := map[string]string {
      1:  "one",
      11: "eleven",
      3:  "three",
   }
   
   for k, v := range m {
       fmt.Println(k, v)
   }
   
   // 可以通过对key进行排序，保证遍历map输出是稳定的
   // To store the keys in slice in sorted order
   var keys []int
   for k := range m {
       keys = append(keys, k)
   }
   sort.Ints(keys)

   for _, k := range keys {
       fmt.Println(k, m[k])
   }
   ```

4. HTTP请求如何保持keep-alive  
   1). Go HTTP Client源码包在 src/net/http/client.go  
   2). http.Client 零值为 DefaultClient = &Client{}，默认是可以直接使用的  
   3). http.Client Transport 是内部状态，会缓存TCP链接（长链接），因此建议重用http.Client 而不是每次都 New一个新的，http.Client 在多个goroutine之间使用是并发安全的
   4). http.Client Timeout 表示从发起请求到整个报文响应结束的超时时间，如果没有设置默认为0，表示无限制   
   5). 常规的http Client定义如下
      ```
       // case 1 
       // Transport If nil, DefaultTransport is used.
       &http.Client{
           Timeout:   timeout,
       }
       // case 2
       &http.Client{
           Timeout:   timeout,
           Transport: &http.Transport{
               ...
           },
       }
      ```
   6). DefaultTransport 结构体定义如下
      ```
       // DefaultTransport is the default implementation of Transport and is
       // used by DefaultClient. It establishes network connections as needed
       // and caches them for reuse by subsequent calls. It uses HTTP proxies
       // as directed by the $HTTP_PROXY and $NO_PROXY (or $http_proxy and
       // $no_proxy) environment variables.
       var DefaultTransport RoundTripper = &Transport{
            Proxy: ProxyFromEnvironment,               
            DialContext: (&net.Dialer{
 	            Timeout:   30 * time.Second,      //连接超时时间
 	            KeepAlive: 30 * time.Second,      //默认开启长连接
 	            DualStack: true, 
            }).DialContext,
            MaxIdleConns:          100,               //最大空闲连接数
            IdleConnTimeout:       90 * time.Second,  //连接最大空闲时间，超过这个时间就会被关闭
            TLSHandshakeTimeout:   10 * time.Second,  //限制TLS握手使用的时间
            ExpectContinueTimeout: 1 * time.Second,
       }
       
       由上可知 DefaultClient 或者 &Client{Timeout:timeout} 这种情况下 默认会使用DefaultTransport，默认是开启了HTTP长连接
      ```
   7). 要支持http keep-alive机制，完整的 http.Client 的定义如下
      ```
       &http.Client{
            Timeout: timeout, //请求发起到HTTP包响应结束超时时间
            Transport: &http.Transport{
                Proxy: http.ProxyFromEnvironment,
                DialContext: (&net.Dialer{
                    Timeout:   30 * time.Second, //连接超时时间
                    KeepAlive: 30 * time.Second, //开启长连接
                }).DialContext,
                MaxIdleConns:        100, //整个接池对所有host的最大连接数量
                MaxIdleConnsPerHost: 100, //对每个请求Host允许最大连接数，一般是Server 2 Server 设置和 MaxIdleConns 一样即可
                IdleConnTimeout:     time.Duration(90 * time.Second),
                TLSClientConfig:     &tls.Config{InsecureSkipVerify: true}, //忽略TLS安全校验
            },
       }
      ```

5. 
       
       
       
       
   
