---
layout:  post    # 使用的布局（不需要改）
catalog: true   # 是否归档
author: 陈国林 # 作者
tags:         #标签
    - Go
---

# 一. 问题总结

文章的目的是为了把使用Golang开发过程中遇到的相关问题记录汇总下来，方便后续再碰到的时候可以快速解决

1. HTTPS请求报 `x509: certificate signed by unknown authority`  
   问题原因: HTTPS证书校验失败  
   解决方案: 定义TLSClientConfig 忽略证书校验
   ```
   tr := &http.Transport {
       TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
   }
   
   client := &http.Client{Transport: tr}
   ```
   
2. Go主协程需要等待其它协程结束后再退出，否则会导致goroutine未结束进程就退出了  
   通常情况下我们会使用一个channel来实现，具体的实现原理是 `channel在没有数据的时候接收操作会一直阻塞`，当所有的goroutine都结束的时候可以close掉这个channel，这样接收操作就不会阻塞，主协程就可以继续往下执行
   ```
   func main() {
       ...
    
       // block until shutdown channel closed
       shutdown := make(chan struct{})
       registerSignal(shutdown)
       // 一直阻塞直到shutdown有数据 或者 被close
       <-shutdown
    
       ...
   }

   // registerSignal register kill signal
   func registerSignal(shutdown chan struct{}) {
       c := make(chan os.Signal)
       signal.Notify(c, os.Interrupt, syscall.SIGHUP, syscall.SIGINT, syscall.SIGTERM)

       go func() {
           defer func() {
           if err := recover(); err != nil {
               log.Error("[registerSignal] panic error: ", log.Object("error", err))
               debug.PrintStack()
           }
       }()

       for sig := range c {
           // close shutdown channel
           close(shutdown)
           log.Info("[registerSignal] receive system signal:" + sig.String() + ", going to shutdown ...")
           return
       }
   }()
   ```

3. 正常情况for循环遍历map是不稳定，key/value输出顺序会变化
   ```
   m := map[string]string {
      1:  "one",
      11: "eleven",
      3:  "three",
   }
   
   for k, v := range m {
       fmt.Println(k, v)
   }
   
   // 可以通过对key进行排序，保证遍历map输出是稳定的
   // To store the keys in slice in sorted order
   var keys []int
   for k := range m {
       keys = append(keys, k)
   }
   sort.Ints(keys)

   for _, k := range keys {
       fmt.Println(k, m[k])
   }
   ```

4. HTTP请求如何保持keep-alive  
   1). Go HTTP Client源码包在 src/net/http/client.go  
   2). http.Client 零值为 DefaultClient = &Client{}，默认是可以直接使用的  
   3). http.Client Transport 是内部状态，会缓存TCP链接（长链接），因此建议重用http.Client 而不是每次都 New一个新的，http.Client 在多个goroutine之间使用是并发安全的  
   4). http.Client Timeout 表示从发起请求到整个HTTP报文响应结束的超时时间，如果没有设置默认为0，表示无限制   
   5). 常规的http Client定义如下
   ```
   // case 1 
   // Transport If nil, DefaultTransport is used.
   &http.Client{
       Timeout:   timeout,
   }
   // case 2
   &http.Client{
       Timeout:   timeout,
       Transport: &http.Transport{
           ...
       },
   }
   ```
   6). DefaultTransport 结构体定义如下
   ```
   // DefaultTransport is the default implementation of Transport and is
   // used by DefaultClient. It establishes network connections as needed
   // and caches them for reuse by subsequent calls. It uses HTTP proxies
   // as directed by the $HTTP_PROXY and $NO_PROXY (or $http_proxy and
   // $no_proxy) environment variables.
   var DefaultTransport RoundTripper = &Transport{
        Proxy: ProxyFromEnvironment,               
        DialContext: (&net.Dialer{
 	        Timeout:   30 * time.Second,      //连接超时时间
 	        KeepAlive: 30 * time.Second,      //默认开启长连接
 	        DualStack: true, 
        }).DialContext,
        MaxIdleConns:          100,               //最大空闲连接数
        IdleConnTimeout:       90 * time.Second,  //连接最大空闲时间，超过这个时间就会被关闭
        TLSHandshakeTimeout:   10 * time.Second,  //限制TLS握手使用的时间
        ExpectContinueTimeout: 1 * time.Second,
   }
       
   由上可知 DefaultClient 或者 &Client{Timeout:timeout} 这种情况下 默认会使用DefaultTransport，默认是开启了HTTP长连接
   ```
   7). 要支持http keep-alive机制，完整的 http.Client 的定义如下
   ```
   &http.Client{
       Timeout: timeout, //请求发起到HTTP包响应结束超时时间
       Transport: &http.Transport{
            Proxy: http.ProxyFromEnvironment,
            DialContext: (&net.Dialer{
                Timeout:   30 * time.Second, //连接超时时间
                KeepAlive: 30 * time.Second, //开启长连接
            }).DialContext,
            MaxIdleConns:        100, //整个接池对所有host的最大连接数量
            MaxIdleConnsPerHost: 100, //对每个请求Host允许最大连接数，一般是Server 2 Server 设置和 MaxIdleConns 一样即可
            IdleConnTimeout:     time.Duration(90 * time.Second),
            TLSClientConfig:     &tls.Config{InsecureSkipVerify: true}, //忽略TLS安全校验
       },
   }
   
   最重要的是以下这2个参数
   1). MaxIdleConns: 整个连接池最大的连接数
   2). MaxIdleConnsPerHost: 对每个请求Host允许最大连接数，一般是Server 2 Server 设置和 MaxIdleConns 一样即可
   ```

5. Go主程序退出时需要保证channel已经被消费完，否则会出现数据未消费完，导致数据丢失问题  
   1). 这个很好解决，我们可以通过另外一个stop channel来实现，原理是 `如果channel为空或者channel为nil，channel的接收操作会一直阻塞`  
   2). 我们只需要主协程(主进程)那边收到系统关闭信号的时候，发起一个channel的close，然后stop channel一直阻塞直到被关闭
   ```
   func main() {
       ...
    
       stopChan := make(chan struct{})
    
       // goroutine 处理channel数据
       go process(stopChan)
    
       // block until stopChan closed
       <- stopChan
    
       ...
   }

   func process(stopChan chan struct{}) {
       // 处理另外一个channel数据
       dataChan := getDataChan() 
    
       for {
           // select会一直阻塞，需要内部自行return 或 break 或 goto
           select {
               case data, ok := <- dataChan:
               // dataChan has closed
               if !ok {
                   close(stopChan)
                   return
               }
           }
       }
   }
   ```
       
6. 减少临时变量的分配，可以提高系统运行效率
    + 在频繁申请内存的地方，使用 sync.pool 方式进行内存管理
    + 小对象合并成结构体一次分配，减少内存分配次数
    + 缓存区内容一次分配足够大小空间，并适当复用
    + slice 和 map 采 make 创建时，预估大小指定容量
    + 调用栈避免申请较多的临时对象
    + 减少 []byte 与 string 之间转换，尽量采用 []byte 来字符串处理
       
7. 开发过程中，踩过的坑
    + 






   
