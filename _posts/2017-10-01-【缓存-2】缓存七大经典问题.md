---
layout:  post  # 使用的布局（不需要改）
catalog: true  # 是否归档
author: 陈国林 # 作者
tags:          #标签
    - 缓存
---

# 一. 缓存失效
我们知道缓冲的性能是DB的50~100倍，因为我们希望能够借助缓存实现数据快速访问同时达到性能最高。

1. 缓存失效: 大部分情况下业务数据写缓存都是`key:value`形式，如果某个时间点业务key大量失效，导致请求缓存未命中穿透到DB后DB压力明显上升，系统性能变差最终影响业务请求。
2. 缓存失效原因: 跟我们设置的key过期时间相关
   + 正常写缓存的时候都会给每个key设置一个过期时间，因为key是慢慢写入的，所以不会出现大量key同时过期
   + 某个特殊的场景，我们会主动/被动的加载一批数据到缓存，这个时候如果设置的过期时间一样就会出现同一批key同时过期问题。当这批key都过期之后，请求穿透到DB，因为DB的性能比缓存差很多，就会导致DB压力大增最终影响业务
3. 缓存失效场景
   + 火车票: 同一批次火车票在同一个时间点一起加载到缓存，某个时间出现同一批key同时过期问题，业务大量读写请求直接穿透到DB
   + 热门微博: 微博离线系统，分钟/小时级别计算出当前热门的一批微博并加载到缓存，某个时间出现同一批key同时过期问题，业务大量读写请求直接穿透到DB
   + 缓存预热: 系统一次性预加载一批数据，某个时间出现同一批key同时过期问题，业务大量读写请求直接穿透到DB
4. 缓存失效解决方案: 对每个key不再设置固定的过期时间，而是使用公式 `base+random` 计算出一个过期时间，这样保证每个key的过期时间不同。base表示原来过期时间，random表示随机值



# 二. 缓存穿透

# 三. 缓存雪崩

# 四. 数据不一致

# 五. 数据并发竞争

# 六. Hot key

# 七. Big key
