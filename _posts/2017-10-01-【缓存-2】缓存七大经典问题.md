---
layout:  post  # 使用的布局（不需要改）
catalog: true  # 是否归档
author: 陈国林 # 作者
tags:          #标签
    - 缓存
---

# 一. 缓存失效
我们知道缓冲的性能是DB的50~100倍，因为我们希望能够借助缓存实现数据快速访问同时达到性能最高。

1. `缓存失效`: 大部分情况下业务数据写缓存都是`key:value`形式，如果某个时间点业务key大量失效，导致请求缓存未命中穿透到DB后DB压力明显上升，系统性能变差最终影响业务请求。
2. `缓存失效原因`: 跟我们设置的key过期时间相关
   + 正常写缓存的时候都会给每个key设置一个过期时间，因为key是慢慢写入的，所以不会出现大量key同时过期
   + 某个特殊的场景，我们会主动/被动的加载一批数据到缓存，这个时候如果设置的过期时间一样就会出现同一批key同时过期问题。当这批key都过期之后，请求穿透到DB，因为DB的性能比缓存差很多，就会导致DB压力大增最终影响业务
3. `缓存失效场景`
   + 火车票: 同一批次火车票在同一个时间点一起加载到缓存，某个时间出现同一批key同时过期问题，业务大量读写请求直接穿透到DB
   + 热门微博: 微博离线系统，分钟/小时级别计算出当前热门的一批微博并加载到缓存，某个时间出现同一批key同时过期问题，业务大量读写请求直接穿透到DB
   + 缓存预热: 系统一次性预加载一批数据，某个时间出现同一批key同时过期问题，业务大量读写请求直接穿透到DB
4. `缓存失效解决方案`: 对每个key不再设置固定的过期时间，而是使用公式 `base+random` 计算出一个过期时间，这样保证每个key的过期时间不同。base表示原来过期时间，random表示随机值  

# 二. 缓存穿透
正常情况下我们访问缓存的策略是: 如果命中缓存直接返回，如果没有命中则从DB中读然后再回写到缓存。

1. `缓存穿透`: 有一批特殊的请求正在查询一个不存在的key，每次请求都无法命中缓存，查询DB后返回一个空数据，这个数据并不会写到缓存，所以导致每次请求都穿透到DB，对DB造成巨大的压力。因为DB的性能只有缓存的1%~5%，所以系统性能就会急剧下降。
2. `缓存穿透原因`: 我们在做系统设计的时候考虑的更多的正常的case而忽略了异常的case，这些异常case会直接穿透到DB
3. `缓存穿透场景`
   + 通过不存在的UID访问不存在的用户信息，导致每次请求都直接穿透到DB
   + 通过不存在的车次ID查询不存在的火车票信息，导致每次请求都直接穿透到DB
4. `缓存穿透解决方案`
   + 方案一: `对不存在的key也写到缓存中`，只不过存储的值是特殊值，这样就不会每次请求都穿透到DB。但是这个方案有个问题，如果不存在的key非常多，会占用很多缓存空间，导致正常key的命中率下降
     + `所以我们可以对这些不存在的key只存一个相对较短的时间(30s)，让这些key尽快过期`
     + `把这些不存在的key存储在另外一个独立缓存中`，业务在查找的时候先查正常缓存，如果命中则直接返回，如果未命中则查独立缓存，如果命中独立缓存之间返回，如果未命中独立缓存则查DB，DB查出来有数据则回写到正常缓存中，DB查出来没有数据则回写到独立缓存中
   + 方案二: `构建一个布隆过滤器`，把这些非法的key给阻挡了，通过空间换时间非常高效，具体算法可以参考 [布隆过滤器算法](https://chenguolin.github.io/2018/09/20/%E7%AE%97%E6%B3%95-3-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%AE%97%E6%B3%95/)。
     + `通过布隆过滤器预选存储所有正常key`，查缓存之前先查一下布隆过滤器，如果返回不存在说明key肯定不存在直接返回，否则就正常查缓存，但是这就要求key的数量太多
     + `通过布隆过滤器存储不存在key`，每次查询到不存在key就加入到布隆过滤器中。查缓存之前先查一下布隆过滤器，如返回不存在说明key可能是正常的就正常查缓存，否则直接返回，但是这种情况是布隆过滤器会慢慢膨胀，需要定期做清零处理

# 三. 缓存雪崩

# 四. 数据不一致

# 五. 数据并发竞争

# 六. Hot key

# 七. Big key
