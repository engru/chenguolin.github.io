---
layout:  post    # 使用的布局（不需要改）
catalog: true   # 是否归档
author: 陈国林 # 作者
tags:         #标签
    - Go
---

1. Go 版本历史
    + `go 1.0`: 2012/03/28 released
    + `go 1.1`: 2013/05/13 released
    + `go 1.2`: 2013/12/01 released
    + `go 1.3`: 2014/06/18 released
    + `go 1.4`: 2014/12/10 released
    + `go 1.5`: 2015/08/19 released   (自举)
    + `go 1.6`: 2016/02/17 released
    + `go 1.7`: 2016/08/15 released   (极速GC)
    + `go 1.8`: 2017/02/16 released
    + `go 1.9`: 2017/08/24 released
    + `go 1.10`: 2018/02/16 released  (自带工具全面升级)
    + `go 1.11`: 2018/08/24 released
    + `go 1.12`: 2019/02/25 released
2. Go 3个核心环境变量
    + `GOROOT`: Go 语言安装根目录的路径，也就是 GO 语言的安装路径（目前开发在用的是go 1.11.4版本）
    + `GOPATH`: 用户自定义的工作目录
    + `GOBIN`: GO 程序生成的可执行文件（executable file）存放目录
3. Go 25个关键字
    + var和const: 变量和常量申明
    + package和import: 包相关声明和导入
    + func: 用于定义函数和方法
    + return: 用于从函数返回
    + defer: 用于类似析构函数
    + go: 用于并发
    + select: 用于选择不同类型的通讯
    + interface: 用于定义接口
    + struct: 用于定义抽象数据类型
    + break、case、continue、for、fallthrough、else、if、switch、goto、default
    + chan: 用于channel通讯
    + type: 用于声明自定义类型
    + map: 用于声明map类型数据
    + range: 用于读取slice、map、channel数据
4. Go 语言string、byte、rune区别
    + string底层是用byte数组存储的，并且是不可改变的。例如s := "Go编程", len(s) = 8，因为Unicode中文字符占3个字节
    + len(string(rune("编"))) 结果是3，说明string中有Unicode中文字符用3byte存储
    + len([]rune("Go编程”)) 结果是4，rune可以切片，并不是按照Unicode 3个字节存储中文
5. Go 变量
    + `:=` 可以用来简短声明一个变量，只能在函数内部使用
    + 一般用 `var` 声明一个全局变量
    + `_` 下划线变量是一个特殊的变量，任何赋予它的值都会被丢弃
    + 声明一个常量 const name = value
6. Go 权限
    + 大写字母开头的变量是可导出的并且其它代码包可以读取这些变量，小写字母变量是私有变量并且其它代码包不可以读取这些变量
    + 大写字母开头的函数是公有函数其它代码包可以访问这些函数，小写字母开头的函数是私有函数其它代码包不可以访问这些函数
7. Go 默认
    + Go有两个保留函数`main`和`init`, Go程序会自动调用main和init函数，程序的起始和初始化都在main包
    + 代码包的名称一般会与源码文件所在的目录同名，如果不同名那么在构建、安装的过程中会与代码包名称为准
    + Go字符串默认都是采用`utf-8`编码，Go的字符串是不可改变的，如果要改变字符串可以通过转成byte数组实现
    + make用来对map，slice，channel内存分配, new用来对各种类型内存分配；make返回一个T类型，new返回一个*T指针
    + 数组长度是固定的，切片类型的值是可变长的
    + 某个类型需要`fmt`以特殊的格式输出，必须要实现Stringer这个接口，否则将以默认的方式输出
    + 在同一个函数中，defer函数调用的执行顺序与它们出现顺序完全相反
    + panic的recover需要放在defer语句中才会生效
    + go 命令通常会缓存程序构建的结果，以便在将来的重构中重用，可以通过go env GO CACHE命令查看缓存目录的路径。一旦有任何变动，缓存数据就会失效。go 命令会定期删除最近未使用的缓冲数据，也可以使用go clean -cache命令手动删除
8. Go 数据类型
    + 引用类型: slice、map、channel、func
    + 值类型: 基础数据结构、struct
9. Go interface
    + interface{} 可以存储任何类型的数值，类似C语言的void* 指针
    + interface{} 做为函数参数的时候，函数可以接收任何类型的值。如果函数返interface{}，那也可以返回任何类型的值
    + value, ok = element.(T)，可以用来判断一个对象element是否是T类型。element是一个interface{}对象，value是数值，ok是返回值。例如value，ok = e.(int)
    + struct{}和interface{}类型，表示它既不包含任何字段也不拥有任何方法的空结构体类型，struct{}类型的值只有一个struct{}{}，它占用的内存空间是0字节，非常适合用于传递某种简单信号的元素类型
10. Go goroutine
    + goroutine 是并发的核心，goroutine 实际上指的是协程(用户级调度线程)，但是比系统线程更小，十几个`goroutine`差不多等于五六个线程
    + 每一个独立的Go程序在运行的时候总会有一个主goroutine，这个主goroutine会在Go程序的运行准备工作完成之后被自动启用，并不需要我们做任何手动操作。一旦主goroutine中的代码（main函数中的代码）执行完毕，当前的Go程序就会结束运行
11. Go channel
    + channel 用于在多个goroutine之间通信  （不要使用共享内存来通信，而应该使用通信来共享内存）
    + channel 是并发安全的，是Go里面唯一一个可以满足并发安全性的类型
    + channel 可以用goroutine之间通信，必须使用make创建channel。
    + 对于同一个channel，发送操作之间是互斥的，接收操作之间也是互斥的 （同一个时刻只会执同一个channel的任意个发送操作中的某一个，同理接收也是如此，所谓的并发处理，指的是不同goroutine接收，然后在同一个时间内执行）；发送操作和接收操作中对元素值的处理都是不可分割的  （channel中的某一个元素，只可能是某一个发送操作放入的，同时也只可能是被某一个接收操作取出）；发送操作在完全完成之前会被阻塞，接收操作也是如此 （发送或接收操作没有完全完成之前，发起这个操作的代码会一直阻塞在那里）
    + 有buffer channel: 如果channel已满，那么对它的所有发送操作都会被阻塞，直到channel中有元素被取走 （channel会优先通知最早等待发送的goroutine 发送数据）；如果channel已空，那么对它的所有接收操作都会阻塞，直到channel有元素出现 （channel会优先通知最早等待接收的goroutine 接收数据）
    + 没有buffer channel: 无论是发送 还是 接收都是阻塞的，直到有配对的发送和接收操作才会开始处理 （实际上是一种同步传递方式）
    + 对于值为nil 的channel，对它的发送和接收操作都会永久阻塞  （只声明channel没有make初始化，默认为nil）
    + channel 一旦关闭再次发送就会panic
    + 单向channel的主要用途主要是用来约束其它代码的行为
    + select语句是专门为channel而设计的
12. Go json
    + struct 转json
        + 只有大写字母的字段才能够被导出
        + 字段的tag是"-"的是不会被输出到json中
        + tag中有自定义名称，则json中会以该名称做为key
        + tag中如果有omitempty，则该字段为空值的时候不会输出到json
        + tag名称必须要使用双引号引起了，例如`json:"name"`
    + json转struct
        + 能够被赋值的字段必须是 大写字母开头的字段，否则无法赋值
        + json序列化的时候只会对能找到的字段进行赋值，找不到的字段不管（有个好处就是json里面有各种字段，但是我们只需要某几个字段的时候就只需要定义某几个字段的struct
13. Go 调度器
    + Go调度器: G（goroutine用户级线程）、P（processor）、M（machine系统级线程）
    + 当程序执行到一条`go`语句的时候，Go语言的运行时系统，会先试图从某个存放空闲G的队列中获取一个G（也就是goroutine），它只有在找不到空闲G的情况下才会去创建一个新的G。（已存在的goroutine会优先被复用）
    + 创建一个G的成本非常低，创建一个G并不会像新建进程或一个系统线程那样，必须通过操作系统的系统调用来完成，在Go语言运行时系统内部就可以做到了
    + 只要`go`语句本身执行完毕，Go程序完全不会等待go函数的执行，它会立刻执行后边的语言 （这就是所谓的异步编程）
    + Go 语言并不会保证goroutine会以怎样顺序执行
14. Go select
    + select 是Go中的一个控制结构，类似于switch语句，用于处理异步IO操作。
    + select 会监听case语句中channel的读写操作，当case中channel读写操作为非阻塞状态（即能读写）时，将会触发相应的动作。
    + 如果有多个case都可以运行，select会随机公平地选出一个执行，其他不会执行。
    + 如果没有可运行的case语句，且有default语句，那么就会执行default的动作。
    + 如果没有可运行的case语句，且没有default语句，select将阻塞，直到某个case通信可以运行
    + 当case上读一个channel时，如果这个channel是nil，则该case永远阻塞。select通常处理的是多个channel，当某个读channel关闭了，但不想select再继续关注此case，继续处理其他case，把该通道设置为nil即可
15. Go 初始化过程  
    + main -> import pkg (递归迭代 pkg->pkg2->pkg3 ...) -> const -> var -> init -> main
   ![](https://github.com/chenguolin/chenguolin.github.io/blob/master/data/image/go-init-pipeline.png?raw=true)


