---
layout:  post    # 使用的布局（不需要改）
catalog: true   # 是否归档
author: 陈国林 # 作者
tags:         #标签
    - Linux
---

# 一. ldd
`ldd` 用来查看可执行文件运行所需的依赖库，常用来解决因缺少某个库文件而不能运行的一些问题。`ldd` 查看可执行文件的依赖库的工作原理，本质是通过`ld-linux.so` 来实现的。

```
$ ldd test
libstdc++.so.6 => /usr/lib64/libstdc++.so.6 (0x00000039a7e00000)
libm.so.6 => /lib64/libm.so.6 (0x0000003996400000)
libgcc_s.so.1 => /lib64/libgcc_s.so.1 (0x00000039a5600000)
libc.so.6 => /lib64/libc.so.6 (0x0000003995800000)
/lib64/ld-linux-x86-64.so.2 (0x0000003995400000)
```

# 二. lsof
`lsof（list open files）`是一个查看当前系统文件的工具，在linux环境下任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。

1. 查看所有打开的文件
   ```
   $ lsof
   COMMAND     PID      USER   FD      TYPE             DEVICE SIZE/OFF       NODE NAME
   init          1      root  cwd       DIR              253,0     4096          2 /
   init          1      root  rtd       DIR              253,0     4096          2 /
   init          1      root  txt       REG              253,0   150352    1310795 /sbin/init
   init          1      root  mem       REG              253,0    65928    5505054 /lib64/libnss_files-2.12.so
   ```
2. 查找打开某个文件相关的进程
   ```
   $ lsof /bin/sh
   COMMAND   PID USER  FD   TYPE DEVICE SIZE/OFF   NODE NAME
   bash     1264 root txt    REG    8,3   944184 392451 /bin/bash
   bash    24173  cgl txt    REG    8,3   944184 392451 /bin/bash
   bash    31744 zb10 txt    REG    8,3   944184 392451 /bin/bash
   ```
3. 列出某个用户打开的文件
   ```
   $ lsof -u cgl
   COMMAND   PID USER   FD   TYPE             DEVICE SIZE/OFF    NODE NAME
   sshd    24152  cgl  cwd    DIR                8,3     4096       2 /
   sshd    24152  cgl  rtd    DIR                8,3     4096       2 /
   sshd    24152  cgl  txt    REG                8,3   575192 1183078 /usr/sbin/sshd
   sshd    24152  cgl  DEL    REG                0,4          2344482 /dev/zero
   sshd    24152  cgl  mem    REG                8,3    18600 1444476 /lib64/security/pam_limits.so
   ...
   ```
4. 列出某个进程所打开的文件
   ```
   $lsof -c bash   //或使用 ($ lsof -p {pid})
   bash     1264 root    0u   CHR                5,1      0t0    5679 /dev/console
   bash     1264 root    1w  FIFO                0,8      0t0    9855 pipe
   bash     1264 root    2w  FIFO                0,8      0t0    9855 pipe
   bash    24173  cgl  cwd    DIR                8,3     4096 1314152 /home/cgl
   bash    24173  cgl  rtd    DIR                8,3     4096       2 /
   bash    24173  cgl  txt    REG                8,3   944184  392451 /bin/bash
   bash    24173  cgl  mem    REG                8,3   157072 1311011 /lib64/ld-2.12.so
   ...
   ```
5. 查看所有网络连接
   ```
   $ lsof -i  //($ lsof -i tcp 列出所有TCP连接)
   rsyslogd   1119   root    8u  IPv4   18499      0t0  UDP *:7139
   dnsmasq    1139 nobody    4u  IPv4    9392      0t0  UDP localhost:domain
   dnsmasq    1139 nobody    5u  IPv4    9393      0t0  TCP localhost:domain (LISTEN)
   sshd       1156   root    3u  IPv4    9439      0t0  TCP *:34815 (LISTEN)
   ...
   ```
6. 查看端口占用
   ```
   $ lsof -i:34815
   sshd     1156 root    3u  IPv4    9439      0t0  TCP *:34815 (LISTEN)
   sshd     1156 root    4u  IPv6    9441      0t0  TCP *:34815 (LISTEN)
   ```
7. 查看被显式删除但句柄还被进程持有的文件
   ```
   $ lsof | grep deleted
   sh        12967    cgl    1w      REG                8,3     1896 1315491 /home/cgl/log (deleted)
   sleep     13348    cgl    1w      REG                8,3     1896 1315491 /home/cgl/log (deleted)
   ```

# 三. pstack
`pstack` 命令用于跟踪进程栈，`pstack`命令必须由相应进程的属主或`root`用户 运行，可以使用`pstack`来确定进程挂起的位置。

```
$ pstack 25480
#0  0x000000331e8ac7be in waitpid () from /lib64/libc.so.6
#1  0x000000000043f162 in ?? ()
#2  0x00000000004403ff in wait_for ()
#3  0x0000000000430ec9 in execute_command_internal ()
#4  0x0000000000433563 in ?? ()
#5  0x000000000043036d in execute_command_internal ()
#6  0x00000000004310be in execute_command ()
#7  0x00000000004319c7 in ?? ()
#8  0x0000000000430515 in execute_command_internal ()
#9  0x00000000004310be in execute_command ()
#10 0x000000000041d906 in reader_loop ()
#11 0x000000000041d128 in main ()
```

# 四. strace
`strace` 常用来跟踪进程执行时的系统调用和所接收的信号，在Linux世界进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模式，通过系统调用访问硬件设备。`strace`可以跟踪到一个进程产生的系统调用，包括参数、返回值、执行消耗的时间。

1. 跟踪可执行文件
   ```
   $ strace -f -T -tt -e trace=all ./kafkactl
   10:42:48.992077 execve("./kafkactl", ["./kafkactl"], [/* 26 vars */]) = 0 <0.000080>
   10:42:48.992325 arch_prctl(ARCH_SET_FS, 0x102a150) = 0 <0.000006>
   10:42:48.992392 sched_getaffinity(0, 8192, {3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ...}) = 512 <0.000006>
   10:42:48.992557 mmap(NULL, 262144, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f0ef31b1000 <0.000007>
   ...
   ```
2. 跟踪指定进程
   ```
   $ sudo strace -f -T -tt -e trace=all -p 1282 | head -10
   Process 1282 attached with 25 threads
   [pid  7990] 10:46:26.900631 futex(0x7f47e0002374, FUTEX_WAIT_PRIVATE, 187, NULL <unfinished ...>
   [pid  6278] 10:46:26.900705 restart_syscall(<... resuming interrupted call ...> <unfinished ...>
   [pid  4429] 10:46:26.900720 futex(0x7f47d0002e34, FUTEX_WAIT_PRIVATE, 189, NULL <unfinished ...>
   [pid  2766] 10:46:26.900730 futex(0x7f482037e844, FUTEX_WAIT_PRIVATE, 189, NULL <unfinished ...>
   [pid  1343] 10:46:26.900739 restart_syscall(<... resuming interrupted call ...> <unfinished ...>
   [pid  1342] 10:46:26.900747 restart_syscall(<... resuming interrupted call ...> <unfinished ...>
   [pid  1341] 10:46:26.900756 restart_syscall(<... resuming interrupted call ...> <unfinished ...>
   ```

# 五. 

1. http://linux-training.be/sysadmin/ch08.html
2. https://linuxtools-rst.readthedocs.io/zh_CN/latest/index.html
