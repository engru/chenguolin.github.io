---
layout:  post    # 使用的布局（不需要改）
catalog: true   # 是否归档
author: 陈国林 # 作者
tags:         #标签
    - Go
---

# 一. 概述
Go 是一门非常简单并且有趣的高级程序开发语言，跟其它语言类似它也有一些`陷阱`。很多陷阱并不是Go本身自己的问题，有一些是因为从其它语言的带来的一些习惯，有些是没有考虑清楚细节导致的。

虽然我们日常开发过程用的都是IDE (Goland) 等会自动提示我们，但是这道这些陷阱对我们写出高质量的代码具有非常大的意义。

# 二. 陷阱
1. `左括号不能放在单行`: 很多语言我们可以选择左括号放在哪个位置，但是Go不行，必须放在当前行的最后一个位置
2. `声明变量未使用`: 如果我们在函数内部定义了一个变量但是未使用，会导致编译失败。Go允许全局变量、函数参数未使用。
3. `导入代码包未使用`: 如果我们导入了一个代码包但是并未使用它的任何函数、结构体等，会导致编译失败，真的想导入可以使用 `_` 来忽略编译错误
4. `短变量定义只能在函数内部使用`: myvar := 1 这种方式定义一个变量只能在函数内部使用
5. `不能重复使用短变量定义同一个变量`: 例如 myvar := 1 重复多次
6. `不能使用短变量定义去设置变量某个字段`: 例如 data.result, err := work() 这种方式是不允许的，但是允许 a, b := work() 这种方式
7. `不要使用nil去显式初始化一个变量`: 例如 var a = nil 这种方式是不允许的，会导致编译失败
8. `slice和map零值为nil，不要没有make就直接使用`
   ```
   // slice 以下这种方式编译可以通过，但是不建议使用
   var arr []int
   arr = append(arr, 1)
   
   // map 以下这种方式会导致panic
   var m map[string]int
   m["one"] = 1 //error
   ```
9. `string变量不能被赋值为nil`: 例如 var x string = nil 这种方式是错误的，会编译失败
10. `数组做为函数参数是值拷贝方式`: 最好的方式是使用slice，而不是数组
    ```
    func main() {  
      x := [3]int{1,2,3}

      // 这里的参数使用的是数组，建议使用slice
      func(arr [3]int) {
         arr[0] = 7
         fmt.Println(arr) //prints [7 2 3]
      }(x)

      fmt.Println(x) //prints [1 2 3] (not ok if you need [7 2 3])
    }
    ```
11. `map查询一个不存在的key` 不应该通过value是某个零值类型来判断是否为空
    ```
    x := map[string]string{"one":"a","two":"","three":"c"}

    //不正确方式
    if v := x["two"]; v == "" {
        fmt.Println("no entry")
    }
    
    //正确方式
    if _,ok := x["two"]; !ok {
        fmt.Println("no entry")
    }
    ```
12. `不能通过[]方式改变string值`，如果真的要修改string值可以转成byte slice再修改
    ```
    x := "text"
    // 编译错误
    x[0] = 'T'
    fmt.Println(x)
    
    // 正确的方式
    xbytes := []byte(x)
    xbytes[0] = 'T'
    ```
13. `string和byte slice之间转换`
    ```
    // string 2 byte slice
    x := "test"
    bytes := []byte(x)
    
    // byte slice 2 string
    s := string(bytes)
    ```
14. `slice初始化的时候，多行数据都必须使用逗号结尾`
    ```
    func main() {  
       x := []int{
       1,
       2 //error，这里必须有逗号
    }
    ```
15. `map不是并发安全的数据结构` 需要通过sync相关的锁机制来保证并发安全
16. `for range方式遍历map得到结果是不稳定的` Go运行时通过随机顺序来提高整体的性能
    ```
    m := map[string]int{"one":1,"two":2,"three":3,"four":4}
    // 访问顺序不稳定，但并不是每次输出顺序都不一样
    for k,v := range m {
        fmt.Println(k,v)
    }
    ```
17. `Go 不支持++a和--a操作`，Go目前只支持 a++ 和 a-- 这两个操作
18. `结构体小写开头字段不能被导出，也没办法从string反序列得到`
    ```
    type man struct {
	   name string `json:"name"`
    }

    func main() {
       // struct 2 byte slice
       m1 := &man{
		name: "cgl",
	   }
	   bytes, _ := json.Marshal(m1)
       // 打印 {}
	   fmt.Println(string(bytes))
    
       // byte slice 2 struct
	   m := &man{}
	   s := "{\"name\":\"cgl\"}"
	   json.Unmarshal([]byte(s), m)
       // 打印 &{}
	   fmt.Println(m)
    }
    ```
19. `主协程默认不会等待所有goroutine，会直接退出进程`，需要通过channel阻塞 或者 WaitGroup等，来实现主协程等待所有的goroutine结束后再退出
20. `发送数据到一个已经关闭的channel会panic`，从一个已经关闭的channel接收数据是安全的，但是发送数据会导致panic
21. `使用nil channel进行发送和接收会无限block`
    ```
    var ch chan int
    // 无限block
    ch <- 5
    // 无限block
    a := <- ch
    ```
22. `方法Receivers如果是值类型，就无法更改原始数据`，建议方法Receivers使用指针类型
    ```
    type data struct {  
       num int
       key *string
       items map[string]bool
    }

    //正确方式
    func (this *data) pmethod() {  
       this.num = 7
    }

    //错误方式
    func (this data) vmethod() {
       //临时更改，函数退出后num还是7
       this.num = 8
       *this.key = "v.key"
       this.items["vmethod"] = true
    }
    ```
23. `未判断HTTP请求response body是否为nil，直接close可能会导致panic`
    ```
    resp, err := http.Get("https://api.ipify.org?format=json")
    // 如果resp为nil，会panic
    defer resp.Body.Close()
    if err != nil {
        fmt.Println(err)
        return
    }
    
    // 正确的方式是 先判断是否为nil，再使用defer
    resp, err := http.Get("https://api.ipify.org?format=json")
    if err != nil {
        fmt.Println(err)
        return
    }
    //ok, most of the time
    defer resp.Body.Close()
    ```
24. `HTTP连接关闭的设置`: Golang支持HTTP和HTTPS协议连接请求，默认使用HTTP/1.1，同时也支持HTTP/1.2。默认HTTP/1.1使用长连接，因此我们只有显式设置关闭连接才会在请求结束之后关闭连接。
    ```
    // 方法一
    // request变量Close字段设置为true 或者 在请求header里加Connection字段值设置为close
    req, err := http.NewRequest("GET","http://golang.org",nil)
    if err != nil {
        fmt.Println(err)
        return
    }

    req.Close = true
    //or do this:
    //req.Header.Add("Connection", "close")
    
    
    // 方法二
    // 通过设置Transport关闭长连接
    tr := &http.Transport{DisableKeepAlives: true}
    client := &http.Client{Transport: tr}

    resp, err := client.Get("http://golang.org")
    if resp != nil {
        defer resp.Body.Close()
    }
    ```
    
    
    
    


