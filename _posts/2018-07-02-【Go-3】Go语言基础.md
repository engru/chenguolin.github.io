---
layout:  post  # 使用的布局（不需要改）
catalog: true  # 是否归档
author: 陈国林 # 作者
tags:          #标签
    - Go
---

1. Go语言string／byte／rune区别
    * string底层是用byte数组存储的，并且是不可改变的。例如s := “Go编程” len(s) = 8，因为Unicode中文字符占3个字节
    * len(string(rune(“编"))) 结果是3，说明string中有Unicode中文字符用3byte存储
    * len([]rune(“Go编程”)) 结果是4，rune可以切片，并不是按照Unicode 3个字节存储中文

2. go基础
    * := 取代了var type，为简短声明。只能在函数内部使用，一般用var声明一个全局变量
    * _ 下划线变量是一个特殊的变量，任何赋予它的值都会被丢弃
    * const name = value 声明一个常量
    * go的字符串都是采用utf-8编码，go的字符串是不可改变的。如果要改变字符串可以通过转成byte数组实现
    * go 默认2个行为
        * 大写字母开头的变量是可导出的，其它包可以读取，公有变量。小写字母是私有变量
	* 大写字母开头的函数是公有函数，小写字母开头的函数是私有函数
    * array: 静态数组, slice: 动态数组, 使用和array类似修改底层array
    * make用来对map，slice，channel内存分配, new用来对各种类型内存分配
      make返回一个T类型，new返回一个*T指针
    * go有两个保留函数main和init, go程序会自动调用main和init函数。程序的起始和初始化都在main包

3. go底层数据存储结构
![](http://static.oschina.net/uploads/img/201604/08013329_D3Pt.png)

4. main包初始化过程
![](https://images2015.cnblogs.com/blog/593225/201609/593225-20160930112201594-1498540791.png)

5. interface
    * 空的interface (interface{}) 可以存储任何类型的数值，类似C语言的void* 指针
    * 空的interface做为函数参数的时候，函数可以接收任何类型的值。如果函数返回空的interface，那也可以返回任何类型的值
    * 某个类型需要fmt以特殊的格式输出，必须要实现Stringer这个接口，否则将以默认的方式输出
    * value, ok = element.(T), 可以用来判断一个对象element是否是T类型。element是一个空interface对象，value是数值，ok是返回值。例如value，ok = e.(int)

6. 并发
    * goroutine是并发的核心
    * goroutine实际上是协程，但是比线程更小，十几个goroutine差不多等于五六个线程
    * channel可以用goroutine之间通信，必须使用make创建channel。默认情况下 channel的接收和发送都是阻塞的，所以goroutine的同步比较简单，不需要显示的lock
    * 可以通过range不断读取channel的数据，直到有显式的close

7. go 25个关键字
    * var和const参考2.2Go语言基础里面的变量和常量申明
    * package和import 包相关声明和导入
    * func 用于定义函数和方法
    * return 用于从函数返回
    * defer 用于类似析构函数
    * go 用于并发
    * select 用于选择不同类型的通讯
    * interface 用于定义接口，参考2.6小节
    * struct 用于定义抽象数据类型，参考2.5小节
    * break、case、continue、for、fallthrough、else、if、switch、goto、default这些参考2.3流程介绍里面
    * chan用于channel通讯
    * type用于声明自定义类型
    * map用于声明map类型数据
    * range用于读取slice、map、channel数据

8. json
    * struct 转json
        * 只有大写字母的字段才能够被导出
	* 字段的tag是“-”的是不会被输出到json中
	* tag中有自定义名称，则json中会以该名称做为key
	* tag中如果有omitempty，则该字段为空值的时候不会输出到json
    * json转struct
	* 能够被赋值的字段必须是 大写字母开头的字段，否则无法赋值
        * json序列化的时候只会对能找到的字段进行赋值，找不到的字段不管（有个好处就是json里面有各种字段，但是我们只需要某几个字段的时候就只需要定义某几个字段的struct）


