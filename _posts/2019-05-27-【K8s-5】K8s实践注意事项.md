---
layout:  post  # 使用的布局（不需要改）
catalog: true  # 是否归档
author: 陈国林 # 作者
tags:          #标签
    - K8s
---

# 注意事项
1. 如果容器1号进程是shell脚本，应用进程是这个shell进程的子进程，那这个shell进程是收不到 SIGTERM 信号的
   ```
   这种启动方式是Pod配置文件container启动参数的shell脚本，例如 "/bin/sh /run.sh -c ..."，这种方式业务应用进程是通过run.sh脚本启动
   在容器内部，PID为1进程为run.sh，业务进程为1号进程子进程
   
   这种方式有个问题就是，容器内1号是收不到操作系统 SIGTERM 信号的，具体可以参考
   
   Note: A process running as PID 1 inside a container is treated specially by Linux: it ignores any signal with the default action. 
   So, the process will not terminate on SIGINT or SIGTERM unless it is coded to do so.
   
   One mistake which is pretty common and something which can be missed is using the non-exec form of CMD.
   for example, then your process is running as a child process of shell and not really running as root. It will be running as /bin/sh -c myapplication
   
   The problem with this is that, shell will never forward this signal to the child process, which is your application process and it will not be able to handle the SIGTERM for which you have written a handler for.
   
   In any case, this would make your process be SIGKILLed. Instead one should use the exec form CMD
   ```

2. 容器Pod一直处于Blocked状态，通过describe命令发现Pod有 `forbidden sysctl: "net.core.somaxconn" not whitelisted` 这个信息
   ```
   原因是kubelet没有开启unsafe机制，而我们又在Pod yaml配置文件里面定义了以下配置
   securityContext:
        sysctls:
        - name: net.core.somaxconn
          value: "10000"
          
   解决方案是: 可以先把securityContext配置去掉，但是这个配置会影响整个Pod内容器最大链接数，默认为128，明显是不够。另外我们需要在kubelet上把对应配置开起来，保证配置可以验证通过，不至于kubelet fail fast
   ```
   可以参考官方文档: https://kubernetes.io/docs/tasks/administer-cluster/sysctl-cluster/
   
 
