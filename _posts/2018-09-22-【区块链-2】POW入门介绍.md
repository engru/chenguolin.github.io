---
layout:  post    # 使用的布局（不需要改）
catalog: true   # 是否归档
author: 陈国林 # 作者
tags:         #标签
    - 区块链
---   


POW: Proof of Work 工作量证明

# 一. 共识是一个多维博弈过程
1. 共识越分散（节点多，参与度高），效率越低，但是安全性越高，就越稳定；相反共识越集中（节点垄断），效率越高，容易出现独裁和腐败，安全性越低。
2. 同时能源消耗与有意义的计算也是一种博弈，比如消耗资源减少（算力减少），安全性就越低，比如最近的51%攻击，一些大算力矿池的币，将算力切换到小算力的币，就很容造成51%攻击，很容易分叉主链；有意义的计算与区块链系统连接起来，而不仅仅是简单的消耗大量算力竞争记账权，计算那些随机的没有意义的数学难题，没有获得记账权的矿工没有任何收益，并且投入算力就白白浪费，靠算力说话的世界，小矿池基本已经没有能力参与竞争，算力集中与去中心相悖。比如投入算力到星空天体结构计算，蛋白质分子计算，基因工程计算等等，会更有价值的。

特点：根据工作量证明来执行货币的分配，算力越高、挖矿时间越长，获得的奖励就越多。

一个符合要求的Block Hash由N个前导零构成，零的个数取决于网络的难度值。要得到合理的Block Hash需要经过大量尝试计算，计算时间取决于机器的哈希运算速度。参与挖矿的矿工竞争将前一区块的hash与一个随机的比特串一起来计算出一个hash值，若输出的hash值满足前若干比特为0，即为解出了该难题，当然，并不能得出计算次数的绝对值，因为寻找合理hash是一个概率事件。当节点拥有占全网n%的算力时，该节点即有n/100的概率找到Block Hash。
![](https://upload-images.jianshu.io/upload_images/528413-aa2e914fe136b580.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp)   
![](https://upload-images.jianshu.io/upload_images/528413-cdd13aad489ddb2b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp)

优点
1. 完全去中心化
2. 节点自由进出，容易实现
3. 破坏系统花费的成本巨大

缺点
1. 区块的确认时间难以缩短，并且交易的确认时间需要10-16分钟，不能满足实时性需求
2. 新的区块链必须找到一种不同的散列算法，否则就会面临比特币的算力攻击
3. 浪费能源

# 二. POW计算过程
比特币挖矿使用的hashcash工作量证明算法，hashcash算法要求有以下几个参数
1. 一个字符串string
2. 一个随机数nonce
3. 一个计数器counter
 
在比特币里面字符串string是由区块头几个字段编码而来，包括以下几个字段 版本号、前一个区块hash、Merkle树根、时间戳、难度值。随机数nonce存在每个区块的第一笔交易即coinbase里面。计数器counter是一个小于32位的数，每次改变nonce值的时候都需要增加counter值防止重复计算。比特币在挖矿的时候通过改变nonce和counter重复计算hash值，增加nonce必须重新计算Merkle树，因为coinbase在是Merkle树最左边的叶子节点。

区块头包含以下几个字段
1. Version	区块链版本号	升级软件的时候会更新版本	4字节
2. hashPrevBlock  前一个区块256bit hash值 收到一个新的区块	32字节
3. hashMerkleRoot  当前区块所有交易Merkle树根 256bit hash值	收到新的交易	32字节
4. Time	当前时间戳 (从1970-01-01 00:00:00 秒数)	每秒更新	4字节
5. Bits  当前目标值的压缩格式	难度更新的时候	 4字节
6. Nonce  从0开始的32位随机数  重新计算hash的时候	4字节

交易包含在区块的body里面，计算sha256 hash值的时候只用到Merkle root，并不直接计算交易的hash。因此一个区块包含1笔交易和1000笔交易并无区别。当前目前值会被压缩成3个字节，Bits第一个字节表示的是指数值，Bits值是所有节点都一样。每个节点时间戳可能会有一些区别，Nonce肯定是不一样的，但是所有的节点都是从0开始线性增长。另外，所有节点的Merkle root都是不一样的，因为所有节点区块的第一笔交易coinbase都不一样，因为coinbase的收款地址都不一样。所有每个节点计算出小于目标值的概率是一样的。
  
比特币使用hash算法是 SHA256(SHA256(Block_Header)) 但是我们需要关心字节的顺序。
```
>>> import hashlib
>>> header_hex = ("01000000" +
 "81cd02ab7e569e8bcd9317e2fe99f2de44d49ab2b8851ba4a308000000000000" +
 "e320b6c2fffc8d750423db8b1eb942ae710e951ed797f7affc8892b0f1fc122b" +
 "c7f5d74d" +
 "f2b9441a" +
 "42a14695")
>>> header_bin = header_hex.decode('hex')
>>> hash = hashlib.sha256(hashlib.sha256(header_bin).digest()).digest()
>>> hash.encode('hex_codec')
‘1dbd981fe6985776b644b173a4d0385ddc1aa2a829688d1e0000000000000000’         //大端表示
>>> hash[::-1].encode('hex_codec')
‘00000000000000001e8d6829a8a21adc5d38d0a473b144b6765798e61f98bd1d’        //小端表示
```

# 三. 大小端表示
1. Little-Endian就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。 
2. Big-Endian就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。（人类读写数值方法）

举一个例子，比如数字0x12 34 56 78在内存中的表示形式为
1. 大端模式： 0x12 0x34 0x56 0x78   【比较符合人类阅读习惯】
2. 小端模式： 0x78 0x56 0x34 0x12

